# ATS Database Schema - Architecture Decision Record

**Status**: ‚úÖ **14 TABLES LOCKED & VALIDATED** - Complete ATS Core Schema Finalized  
**Last Updated**: 2025-08-20

## üèóÔ∏è **THREE ARCHITECTURAL PATTERNS FOR CONSTRAINED VALUES (2025-08-20)**

### **Pattern 1: Company-Level Customization ‚Üí Lookup Tables**
**Characteristics**: Each organization needs different values  
**Fields**: `user_roles`, `hiring_stages`, `candidate_sources`  
**Winner**: Lookup Tables (only option supporting per-company values)

### **Pattern 2: Global Standards ‚Üí Application Constants + CHECK**  
**Characteristics**: Industry-standard values, stable, no customization  
**Fields**: `account_status`, `tenant_types`, `contact_types`, `experience_level`, `application_status`  
**Winner**: App Constants (best performance + easy additions)

### **Pattern 3: Regional/Static Values ‚Üí App Constants (Split Hair with JSON)**  
**Characteristics**: Values vary by country/region but are still static
**Fields**: `work_authorization`, `education_level`  
**Conclusion**: **Split hair** between App Constants and JSON Config - functionally identical approaches. Both require deployment for changes. Pick one and stick with it.

---

## üîß **APPROVED CONSTRAINED VALUES IMPLEMENTATIONS**

### **APPROVED: USER_ROLES Field (Pattern 1)**
**Decision**: Lookup Table approach  
**Score**: 57 points (vs ENUM: 20, App Constants: 28, JSON Config: 48)

**Implementation**:
```sql
CREATE TABLE user_roles (
  id SERIAL PRIMARY KEY,
  company_id UUID REFERENCES companies(id),
  role_name VARCHAR(100) NOT NULL,
  description TEXT,
  permissions_json JSONB,
  active BOOLEAN DEFAULT true,
  UNIQUE(company_id, role_name)
);
```

**Scoring Analysis - Company Customization Required**:
| Factor | Weight | ENUM | Lookup Table | App Constants | JSON Config |
|--------|---------|------|--------------|---------------|-------------|
| **Company Customization** | 5x | 0 (Impossible) | 5 (Perfect fit) | 0 (Impossible) | 4 (File per company) |
| **Change Likelihood** | 4x | 1 (ALTER TYPE) | 5 (Simple INSERT) | 2 (Code deploy) | 4 (File edit) |
| **Developer Effort** | 4x | 4 (Simple if worked) | 3 (FK + joins ~50 LOC) | 5 (Constants ~20 LOC) | 3 (Config ~60 LOC) |

**Why Lookup Table Wins**: ENUM and App Constants score 0 for customization (SHOWSTOPPER). Only lookup tables can handle per-company role definitions.

### **APPROVED: ACCOUNT_STATUS Field (Pattern 2)**  
**Decision**: Application Constants + CHECK Constraint  
**Score**: 65 points (vs ENUM: 50, Lookup Table: 45, JSON Config: 32)

**Implementation**:
```sql
account_status VARCHAR(50) NOT NULL 
CHECK (account_status IN ('active', 'inactive', 'suspended', 'pending_verification'))
```
```typescript
const ACCOUNT_STATUS = {
  ACTIVE: 'active',
  INACTIVE: 'inactive', 
  SUSPENDED: 'suspended',
  PENDING: 'pending_verification'
} as const;
```

**Scoring Analysis - Global Standards**:
| Factor | Weight | ENUM | App Constants | Lookup Table | JSON Config |
|--------|---------|------|---------------|--------------|-------------|
| **Company Customization** | 1x | 5 (Not needed) | 5 (Not needed) | 5 (Overkill) | 4 (Complex) |
| **Change Likelihood** | 2x | 1 (300 LOC app changes) | 4 (20 LOC constraint) | 4 (20 LOC table) | 4 (File + app) |
| **Developer Effort** | 4x | 5 (Simple ~10 LOC) | 5 (Constants ~15 LOC) | 2 (JOINs ~50 LOC) | 3 (Config ~40 LOC) |
| **Query Performance** | 4x | 5 (Direct comparison) | 5 (Direct comparison) | 3 (Requires JOINs) | 4 (Memory lookup) |
| **Value Evolution** | 3x | 1 (Complex migration) | 4 (Simple update) | 4 (Simple update) | 3 (Config + deploy) |

**Why App Constants Win**: No customization needed, excellent performance, easy value additions. ENUM loses due to application code change complexity for renames.

### **APPROVED: WORK_AUTHORIZATION Field (Pattern 3)**
**Decision**: JSON Config Files by Country  
**Score**: 72 points (vs ENUM: 35, App Constants: 55, Lookup Table: 58)

**Implementation**:
```sql
work_authorization VARCHAR(100) NOT NULL
```
```typescript
// config/countries/us.json
{
  "work_authorization": [
    "citizen", "permanent_resident", "h1b", "opt", "no_authorization"
  ]
}

// config/countries/uk.json  
{
  "work_authorization": [
    "citizen", "settled_status", "tier2_visa", "student_visa", "no_authorization"
  ]
}
```

**Scoring Analysis - Regional Variations**:
| Factor | Weight | ENUM | App Constants | Lookup Table | JSON Config |
|--------|---------|------|---------------|--------------|-------------|
| **Regional Customization** | 5x | 1 (Single global set) | 2 (Prefix naming) | 4 (Country column) | 5 (Perfect fit) |
| **International Expansion** | 4x | 1 (Hard to add countries) | 3 (Code changes) | 4 (New rows) | 5 (New files) |
| **Change Likelihood** | 3x | 1 (Immigration law changes) | 3 (Code deploy) | 4 (DB updates) | 5 (File updates) |
| **Developer Effort** | 4x | 4 (Simple base) | 4 (Prefix logic ~30 LOC) | 3 (Country joins ~60 LOC) | 3 (Config loading ~50 LOC) |
| **Query Performance** | 3x | 5 (Direct comparison) | 4 (String matching) | 3 (Requires JOINs) | 4 (Memory cache) |

**Why JSON Config Wins**: 
- **Regional Flexibility**: Easy to add new countries without code changes
- **Immigration Law Changes**: Common for work authorization, JSON files updated without deployment
- **Expansion Speed**: New market = new config file, no schema changes
- **Validation**: Application validates against appropriate country config

**Key Assumptions**:
- International expansion likely within 2 years
- Immigration laws change 1-2x per year per country
- Performance acceptable with in-memory config caching
- Country-specific validation more important than referential integrity

**Re-evaluation Trigger**: If >90% usage is single-country, reconsider App Constants approach

---

## üìä **RESEARCHED DEFAULT VALUES BY PATTERN**

### **Pattern 1 Fields (Company Customization) - Lookup Table Examples**

**Starting Values for user_roles table**:
```sql
-- Agency roles (companies customize these)
INSERT INTO user_roles (company_id, role_name, description) VALUES
  (agency_id, 'admin', 'Full administrative access'),
  (agency_id, 'account_manager', 'Client relationship management'),
  (agency_id, 'candidate_recruiter', 'Candidate sourcing and screening'),
  (agency_id, 'recruiting_coordinator', 'Process coordination and scheduling');

-- Employer roles (companies customize these)  
INSERT INTO user_roles (company_id, role_name, description) VALUES
  (employer_id, 'admin', 'Full administrative access'),
  (employer_id, 'hiring_manager', 'Job posting and candidate review'),
  (employer_id, 'recruiter', 'Candidate sourcing and initial screening'),
  (employer_id, 'hr_coordinator', 'Process management and compliance');
```

### **Pattern 2 Fields (Global Standards) - Application Constants**

**From Greenhouse + Competitor Research**:
```typescript
// Industry standard - rarely change
const ACCOUNT_STATUS = {
  ACTIVE: 'active',
  INACTIVE: 'inactive', 
  SUSPENDED: 'suspended',
  PENDING: 'pending_verification'
} as const;

const APPLICATION_STATUS = {
  ACTIVE: 'active',
  REJECTED: 'rejected', 
  HIRED: 'hired',
  CONVERTED: 'converted'  // hired ‚Üí employee record
} as const;

const TENANT_TYPES = {
  EMPLOYER: 'employer',
  AGENCY: 'agency', 
  PLATFORM: 'platform'
} as const;

const EXPERIENCE_LEVEL = {
  ENTRY: 'entry',
  MID: 'mid',
  SENIOR: 'senior', 
  STAFF: 'staff',
  PRINCIPAL: 'principal',
  EXECUTIVE: 'executive'
} as const;

const CONTACT_TYPES = {
  EMAIL: 'email',
  PHONE: 'phone',
  LINKEDIN: 'linkedin',
  GITHUB: 'github', 
  TWITTER: 'twitter',
  PORTFOLIO: 'portfolio',
  WEBSITE: 'website'
} as const;

const JOB_TYPE = {
  FULL_TIME: 'full-time',
  PART_TIME: 'part-time', 
  CONTRACT: 'contract',
  INTERNSHIP: 'internship',
  TEMPORARY: 'temporary'
} as const;

const INTERVIEW_TYPE = {
  PHONE: 'phone',
  VIDEO: 'video',
  IN_PERSON: 'in-person',
  TECHNICAL: 'technical', 
  PANEL: 'panel'
} as const;

const INTERVIEW_STATUS = {
  SCHEDULED: 'scheduled',
  COMPLETED: 'completed',
  CANCELLED: 'cancelled', 
  NO_SHOW: 'no_show'
} as const;
```

### **Pattern 3 Fields (Regional/Expansion) - JSON Config**

**US Market (MVP)**:
```json
// config/countries/us.json
{
  "work_authorization": [
    "citizen",
    "permanent_resident", 
    "h1b",
    "opt",
    "no_authorization"
  ],
  "education_level": [
    "high_school",
    "associates", 
    "bachelors",
    "masters",
    "phd"
  ]
}
```

**UK Market (Future)**:
```json
// config/countries/uk.json  
{
  "work_authorization": [
    "citizen",
    "settled_status",
    "tier2_visa", 
    "student_visa",
    "no_authorization"
  ],
  "education_level": [
    "secondary",
    "a_levels",
    "bachelors", 
    "masters", 
    "phd"
  ]
}
```

---

## üéØ **PATTERN DECISION FRAMEWORK SUMMARY**

### **How to Choose the Right Pattern:**

**1. Ask: "Does each company need different values?"**
- ‚úÖ YES ‚Üí **Pattern 1: Lookup Tables** 
- ‚ùå NO ‚Üí Continue to question 2

**2. Ask: "Do values vary by country/region?"**  
- ‚úÖ YES ‚Üí **Pattern 3: JSON Config**
- ‚ùå NO ‚Üí **Pattern 2: Application Constants**

### **Pattern Characteristics:**

| Pattern | Customization | Change Frequency | Performance | Complexity |
|---------|---------------|------------------|-------------|------------|
| **1: Lookup Tables** | Company-level | Medium (business driven) | Good (JOINs) | High (FK relationships) |
| **2: App Constants** | None | Low (industry standard) | Excellent (direct) | Low (simple validation) |
| **3: JSON Config** | Regional | Medium (regulatory) | Good (memory cache) | Medium (file management) |

### **When Patterns Fail - Red Flags:**

**Pattern 1 ‚Üí 2**: If 90%+ companies use identical values, switch to App Constants  
**Pattern 2 ‚Üí 1**: If companies request customization, switch to Lookup Tables  
**Pattern 2 ‚Üí 3**: If international markets require different values, switch to JSON Config  
**Pattern 3 ‚Üí 2**: If 90%+ usage is single region, switch to App Constants

This framework prevents architecture flip-flopping by providing clear decision criteria and triggers for re-evaluation.

### **Pattern 4: Default Value Strategy**

**Design Rule**: Always distinguish "no data entered" from "explicitly unknown"

**Implementation**:
- **Database Default**: `NULL` (indicates incomplete/missing data)
- **UI Behavior**: `NULL` displays as "Select..." placeholder requiring user action  
- **Explicit "Unknown"**: User must consciously choose when they don't know
- **Why**: Enables data quality tracking and follow-up workflows

**Example**:
```sql
work_authorization VARCHAR(100) DEFAULT NULL -- NULL = incomplete profile
-- vs 'Unknown' = candidate chose "Unknown" option
```

### **Pattern 5: Configuration File Organization**

**Design Rule**: Organize by business domain, not technical structure

**Directory Structure**:
```
src/config/
‚îú‚îÄ‚îÄ work-auth/           # One file per country for regulatory differences
‚îÇ   ‚îú‚îÄ‚îÄ us.json
‚îÇ   ‚îú‚îÄ‚îÄ uk.json
‚îÇ   ‚îî‚îÄ‚îÄ canada.json
‚îú‚îÄ‚îÄ currencies/          # Global financial standards
‚îú‚îÄ‚îÄ locations/           # Geographic hierarchies  
‚îî‚îÄ‚îÄ job-categories/      # Industry classifications
```

## üóÇÔ∏è **COMPLETE FINALIZED SCHEMA (All Locked Tables)**

### **COMPLETE DATABASE SCHEMA**

**Implementation Details**: All CREATE TABLE statements, field specifications, and SQL code have been moved to:
`/Users/april/10x10-Repos/claude-common/docs/Architecture/Complete-Database-Field-Specifications.md`

**This document contains only architectural decisions and rationale. See implementation file for:**
- Complete CREATE TABLE statements for all 14 tables
- Detailed field specifications and constraints
- Application constants and regional configuration examples
- Performance optimization indexes
- FK relationship validation

## üîç **FINAL ARCHITECTURE VALIDATION**

**Complete Schema Audit**: All 14 tables with 18 FK relationships validated ‚úÖ

**Architecture Verification Status**:
- **‚úÖ FK Dependencies**: All foreign key relationships resolved and validated
- **‚úÖ Tenant Isolation**: Database-level RLS prevents cross-tenant data leaks
- **‚úÖ Business Logic**: Complete workflow support (person‚Üíjob‚Üísubmission‚Üíhiring)
- **‚úÖ Data Integrity**: Canonical deduplication + constraint-based conflict prevention
- **‚úÖ Multi-Profile Support**: Same person across multiple tenants/organizations
- **‚úÖ Centralized Permissions**: Role-based access without duplication

**Detailed validation results available in**: `Complete-Database-Field-Specifications.md`

---

## üèõÔ∏è **FINAL HIGH-LEVEL ARCHITECTURE REVIEW**

### **üìä COMPLETE SCHEMA SUMMARY:**

### **üéØ ARCHITECTURE STRENGTHS:**

**1. Security-First Multi-Tenancy:**
- Database-level RLS isolation prevents cross-tenant data leaks
- All business tables include `tenant_id` for foolproof isolation
- FK chains maintain tenant boundaries across all relationships

**2. Canonical Identity System:**
- Person deduplication prevents revenue-critical duplicate placements
- Multi-profile support handles complex real-world scenarios (0.01% but architecturally critical)
- Contact audit trail ensures data integrity and compliance

**3. Centralized Permission Management:**
- Eliminates permission duplication across users
- Tenant-customizable role definitions
- Clean separation of identity vs authorization

**4. Complete Business Process Coverage:**
- End-to-end workflow: Person ‚Üí Job ‚Üí Submission ‚Üí Hiring
- Stage/status/interview progression tracking
- Conflict prevention via unique constraints

**5. Future-Proof Design:**
- Phase II extensions supported without rewrites
- JSONB flexibility for evolving business requirements
- Industry-standard terminology and patterns

### **üîÑ WORKFLOW VALIDATION:**

**Core Business Flows Supported:**

1. **Person Creation & Deduplication:**
   ```sql
   canonical_persons ‚Üí user_profiles ‚Üí contact_identifiers
   -- Automatic duplicate detection via email/phone/social matching
   ```

2. **Multi-Tenant User Management:**
   ```sql
   tenants ‚Üí user_profiles ‚Üí user_role_assignments ‚Üí tenant_roles
   -- Database-enforced tenant isolation with centralized permissions
   ```

3. **Job Lifecycle Management:**
   ```sql
   tenants ‚Üí jobs (draft ‚Üí active ‚Üí closed ‚Üí filled)
   -- Creator permissions via user_profiles FK
   ```

4. **Submission Processing:**
   ```sql
   submissions: candidate_profiles + jobs ‚Üí stage/status progression
   -- Unique constraint prevents duplicate applications
   -- Tenant isolation prevents cross-tenant data access
   ```

### **üöÄ PHASE II READINESS:**

**Confirmed Extension Points:**
- **Department/Location Hierarchy:** Add via new tables, no core table changes
- **Advanced Job Access Control:** Extend `job_access_level` enum values  
- **Enhanced Submission Workflows:** Add workflow tables, keep core submission simple
- **Corporate Tenant Relationships:** Add `tenant_relationships` table
- **Performance Optimization:** Add indexes, partitioning, caching layers

### **üìà SCALABILITY FOUNDATION:**

**MVP ‚Üí Enterprise Path:**
- **Tenant Sharding:** Schema supports horizontal partitioning by `tenant_id`
- **Read Replicas:** All queries can route to read-only instances
- **Caching Layer:** JSONB fields support application-level caching
- **Search Optimization:** Full-text search vectors for job/candidate matching

### **‚úÖ BUSINESS REQUIREMENTS COVERAGE:**

**Critical Requirements Met:**
- ‚úÖ **Revenue Protection:** Canonical deduplication prevents duplicate placements
- ‚úÖ **Multi-Tenant Security:** Database-level isolation compliance-ready
- ‚úÖ **Submission Tracking:** Complete stage/status/interview progression
- ‚úÖ **Role Management:** Centralized, consistent, tenant-customizable
- ‚úÖ **Multi-Profile Users:** Rare but critical edge cases supported
- ‚úÖ **Performance:** Optimized for high-frequency within-tenant queries
- ‚úÖ **Future-Proofing:** Extensions possible without core rewrites

**FINAL ARCHITECTURE STATUS: PRODUCTION-READY** ‚úÖ

---

**Total Locked Tables: 14** 
**Status**: Complete ATS core schema locked ‚úÖ - Person/User/Tenant/Job/Submission architecture finalized

---

1Ô∏è‚É£ Lockdown design principles
	‚Ä¢	Every core decision is documented with:
	1.	What is locked
	2.	Alternatives considered
	3.	Why this option was chosen
	‚Ä¢	Changes are allowed only with justification: explain what problem prompted the change and how it preserves or modifies prior decisions.
	‚Ä¢	Minimal documentation is enough ‚Äî just a couple sentences per table/decision.

3Ô∏è‚É£ Rules to prevent flip-flop
	1.	Reference lockdown table before proposing changes ‚Äî must explicitly justify conflict with prior locks.
	2.	Document reasoning in 1‚Äì2 sentences each time a decision is changed.
	3.	Core IDs:
	‚Ä¢	Person.person_id = canonical anchor
	‚Ä¢	Profile.profile_id = local to profile type
	‚Ä¢	Contacts = FK ‚Üí Person
	‚Ä¢	OrganizationMembership = FK ‚Üí Profile
---

### The Architectural Decision Record (ADR) - v2

This document summarizes the key architectural decisions for the multi-tenant ATS database, including the final rationale, core assumptions, and rebuttals to common objections.

#### 1. The Core Identity Model: "Person-First" Canonical Identity

*   **Decision:** A central `persons` table represents a unique human. All other roles link to this single record.
*   **Core Assumption:** Preventing duplicate person records is a top business priority. The cost of managing duplicate data is higher than the cost of maintaining a central identity table.
*   **Devil's Advocate:** "This seems overly complex. Why not just have separate `candidates` and `users` tables?"
*   **Rebuttal:** A separate-table model inevitably leads to data chaos. The same person will exist in multiple tables, making it impossible to get a 360-degree view of an individual or to reliably detect duplicates. Our "Person-First" model solves this fundamental problem at the structural level, which is simpler in the long run.

#### 2. The Login & Authentication Model: The `user_auth_logins` Table

*   **Decision:** A user's login is managed by `user_auth_logins`. The `login_credential` column **must be unique**.
*   **Core Assumption:** A single login credential (e.g., an email/password combination) must correspond to exactly one user identity within our system for it to be secure and reliable.
*   **Devil's Advocate:** "Why must the login be unique? Can't the application code just ask the user which account they want to use if there are duplicates?"
*   **Rebuttal:** This assumption is the bedrock of system security and integrity. Abandoning it makes critical, non-interactive system actions (like a password reset or an API call) impossible to execute reliably. The system would not know which of the duplicate records to act upon, leading to data corruption and security vulnerabilities. The `UNIQUE` constraint is not a preference; it's a prerequisite for a trustworthy system.

#### 3. The Multi-Tenancy & Permissions Model: The `organization_members` Table

*   **Decision:** A dedicated `organization_members` join table will manage all user-to-organization relationships.
*   **Core Assumption:** The system must be able to support users who belong to more than one organization, even if this is a rare "corner case."
*   **Devil's Advocate:** "This is a corner case. 99.99% of users will only belong to one organization. Why add a table for such a rare scenario?"
*   **Rebuttal:** This addresses the **Asymmetry of Cost**. The cost of adding this table is negligible. The cost of *not* having it is catastrophic‚Äîthe moment a high-value user needs this feature, the system hard-fails and requires an expensive and time-consuming redesign. Furthermore, these "corner case" users (superstar recruiters, consultants) are often the most valuable. The flexibility to support them is a critical business advantage, not a technical indulgence.

#### 4. The Profile Data Model: Separate, Role-Specific Profile Tables

*   **Decision:** Role-specific data (e.g., `commission_rate`) will be stored in separate profile tables (`agency_user_profile`, etc.), not in the `organization_members` table.
*   **Core Assumption:** Different user roles will have significantly different data attributes. Combining them into one table is impractical and will lead to maintenance issues.
*   **Devil's Advocate:** "Why not just have one `user_profiles` table with all possible columns? It's fewer tables."
*   **Rebuttal:** This violates the **Single Responsibility Principle**. A single profile table would be wide, messy, and full of `NULL` values. It would tightly couple unrelated features (e.g., agency commissions and employer hiring settings), meaning a change in one could break the other. Separate tables ensure that the data model is clean, logical, and that features can be developed and maintained independently without unintended side effects.

#### 5. The Contact Information Model: Separate, Strongly-Typed Tables

*   **Decision:** Contact info is stored in separate tables (`person_emails`, `person_phones`, etc.).
*   **Core Assumption:** Data integrity and the ability to store multiple contacts of the same type are more important than minimizing the number of tables.
*   **Devil's Advocate:** "This seems to contradict the logic for membership. Here you are okay with checking three tables to find a person, but not for permissions."
*   **Rebuttal:** This addresses the difference between **Authorization** and **Data Ingestion**. The membership check is a real-time authorization query that must be simple and fast. The duplicate check is a data ingestion task where performance is less critical, but data integrity is paramount. Most importantly, this design does not break **Referential Integrity**. Unlike the profile-as-membership model, this pattern does not prevent other parts of the system from creating reliable foreign keys.


2Ô∏è‚É£ Current lockdown design (canonical summary)

Decision	Lockdown	Alternatives considered	Reason for lock
Person table	Canonical person table, one row per human	Separate per profile or no canonical person	Ensures identity deduplication, supports multiple profiles/orgs
Profile tables	Separate table per type (CandidateProfile, EmployerProfile, RecruiterProfile), each FK ‚Üí Person	One ‚Äúall attributes‚Äù table, supertype table	Avoids bloated nullable columns; clean separation of role-specific attributes; supertype considered but not needed now
Contacts	Three tables (Email, Phone, Social) or one unified table, all FK ‚Üí Person	Store in profile tables	Centralized per person allows deduplication across profiles; separate tables fine, does not impact other core decisions
User table	Optional, FK ‚Üí Person	Embed login info in profiles	Keeps login/auth separate from profile, only for logged-in users
OrganizationMembership	FK ‚Üí Profile (not Person), FK ‚Üí Organization	FK ‚Üí Person	Membership is specific to a profile‚Äôs role in an org; prevents ambiguity across multiple profiles per person
Merge / canonical_person_id	Optional FK in Person pointing to canonical row	No canonical ID, dedup on contact match only	Allows merging duplicates while preserving historical data; optional allows creating Person before canonical determination

### **Decision: User Tables + Contact Table Consolidation (2025-08-14 12:35 PST)**

**Decision**: 
- **Keep 3 separate user tables** - `agency_user`, `employer_user`, `platform_user`
- **Remove organization_contact table** - consolidate into user tables

**Rationale**:
1. **Different Data Structures**: Each user type needs different settings/fields
2. **Unified Identity Model**: Separating "contacts" vs "users" creates split identity problems
3. **Data Fragmentation**: Contact table introduces painful fragmentation for no benefit
4. **Evolving Profiles**: People's roles within organizations evolve - unified model handles this better
5. **Nullable Fields**: User tables already handle many roles with nullable fields

**Key Insight**: The distinction between "user with login" vs "contact without login" is not fundamental to data structure - it's an implementation detail that can be handled via the `users` auth table relationship.

**Alternative Considered**: Separate contact table - rejected due to data fragmentation and split identity problems

‚∏ª

### **Decision: Contact Information Architecture (2025-08-18)**

**Decision**: 
- **Single `contacts` table** with database-level type validation
- **Contact history audit trail** in separate `contact_history` table

**Schema**:
```sql
CREATE TABLE contacts (
  id SERIAL PRIMARY KEY,
  person_id INT REFERENCES persons(id),
  type VARCHAR(20) CHECK (type IN ('email', 'phone', 'social')),
  value TEXT NOT NULL,
  is_primary BOOLEAN DEFAULT false,
  is_active BOOLEAN DEFAULT true,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW(),
  
  -- Database-level type validation
  CONSTRAINT valid_email CHECK (type != 'email' OR value ~ '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$'),
  CONSTRAINT valid_phone CHECK (type != 'phone' OR value ~ '^\+?[1-9]\d{1,14}$'),
  CONSTRAINT valid_url CHECK (type != 'social' OR value ~ '^https?://')
);
```

**Rationale**:
1. **Database integrity**: Type validation enforced at DB level prevents data corruption
2. **Deduplication performance**: Single table enables fast duplicate detection queries  
3. **MVP speed**: Simpler implementation than multi-table approach
4. **Audit requirements**: Contact history tracks changes for duplicate resolution impact

**Alternatives Considered & Rejected**:
- **Option A - Contact columns in profile tables**: 
  - **Rejected because**: Can't handle multiple contacts per person (2% have multiple emails)
  - **Rejected because**: No audit trail support for contact changes
  - **Rejected because**: Duplicates contact validation logic across candidate/recruiter/employer tables
- **Option C - Separate tables (emails, phones, social_urls)**:
  - **Rejected because**: Deduplication queries require 3-table UNION operations
  - **Rejected because**: More complex schema management for same validation benefits
  - **Rejected because**: Not critical for MVP volumes, adds unnecessary complexity

**Business Impact**: Revenue protection through fast, reliable candidate deduplication across all contact types

‚∏ª

### **Decision: Duplicate Detection Strategy (2025-08-18)**

**Decision**: 
- **Canonical Person ID approach** - each duplicate group shares same `canonical_person_id`
- **Schema**: Add `canonical_person_id` field to candidates table, no separate duplicates table

**Final Weighted Score**: Approach B (396 points) vs Approach A (363 points) = 9% advantage

**Detailed Analysis by Priority:**

**P1 - Add Candidate + Duplicate Detection (Weight 5x):**
- Code: 15 vs 25 lines (10 line advantage for B)
- Logic: Simple canonical ID assignment vs N√óN relationship management
- Operations: 2 DB ops vs 6 DB ops (negligible at MVP scale)

**P2 - Real-time Submission Detection (Weight 4x):**
- Performance: Both ~5-10ms (negligible difference)
- Query complexity: Nearly identical

**P3 - History Tracking (Weight 3x):**
- Both approaches support contact change audit equally
- No meaningful difference

**P4 - Contact Info Changes (Weight 2x):**
- Code: 10 vs 20 lines (10 line advantage for B)  
- Logic: Single field update vs delete-all-rebuild cycle

**P5 - Delete Consistency (Weight 1x):**
- Approach A: CASCADE DELETE (simpler)
- Approach B: Canonical ID reassignment (+10 lines)

**P6 - Unique Candidate Queries (Weight 1x):**
- Code: 8 vs 20 lines (12 line advantage for B)
- Query: Simple DISTINCT vs complex group logic

**Total Code Difference**: 60 vs 85 lines (30% more for Approach A)

**Alternatives Considered & Rejected**:
- **Approach A (Duplicates Relationship Table)**:
  - **Rejected because**: 30% more code (25 additional lines)
  - **Rejected because**: N√óN relationship management complexity
  - **Rejected because**: Delete-rebuild cycle for contact changes
  - **Advantage**: Slightly simpler deletion handling (not significant)

**Key Assumptions**:
- Duplicate groups remain small (<5 people typically)
- Contact changes are rare but business-critical
- Solo developer context prioritizes code simplicity
- MVP scale: ~1000 candidates, <1% duplicates

**Assumption Change Triggers**:
- If duplicate groups regularly exceed 10+ people ‚Üí re-evaluate canonical ID performance
- If contact change frequency >10% ‚Üí re-evaluate approach complexity
- If audit requirements demand relationship-level tracking ‚Üí consider Approach A

**Cross-Table Dependencies**:
- Submissions table will use person_id, relying on canonical duplicate resolution
- Jobs table design assumes person-level duplicate detection works
- Organization isolation must work with canonical_person_id visibility

**Detailed Implementation Analysis:**

**SQL Queries for Each Approach:**

*P1 - Add New Candidate:*
```sql
-- Approach A (Rejected):
INSERT INTO duplicates VALUES (newId, existingId1), (newId, existingId2), 
  (existingId1, newId), (existingId2, newId), (existingId1, existingId2), (existingId2, existingId1)

-- Approach B (Selected):
SELECT canonical_person_id FROM candidates WHERE id = existingId1;
INSERT INTO candidates (..., canonical_person_id = ?) VALUES (...)
```

*P2 - Submission Duplicate Check:*
```sql
-- Approach A (Rejected):
SELECT COUNT(*) FROM submissions s WHERE s.employer_id = ? 
AND (s.person_id = ? OR s.person_id IN (
  SELECT duplicate_person_id FROM duplicates WHERE person_id = ?))

-- Approach B (Selected):
SELECT COUNT(*) FROM submissions s JOIN candidates c ON s.person_id = c.id
WHERE s.employer_id = ? AND c.canonical_person_id = (
  SELECT canonical_person_id FROM candidates WHERE id = ?)
```

*P4 - Contact Info Change:*
```sql
-- Approach A (Rejected):
DELETE FROM duplicates WHERE person_id = ? OR duplicate_person_id = ?;
-- Then rebuild N√óN relationships

-- Approach B (Selected):
UPDATE candidates SET canonical_person_id = newCanonicalId WHERE id = ?
```

*P6 - List Unique Candidates:*
```sql
-- Approach A (Rejected):
SELECT COUNT(DISTINCT CASE WHEN EXISTS(SELECT 1 FROM duplicates WHERE person_id = c.id) 
  THEN (SELECT MIN(duplicate_person_id) FROM duplicates WHERE person_id = c.id)
  ELSE c.id END) FROM candidates c

-- Approach B (Selected):
SELECT COUNT(DISTINCT canonical_person_id) FROM candidates
```

**Scoring Details:**
- P1: A=115pts, B=125pts (Weight 5x)
- P2: A=100pts, B=100pts (Weight 4x)  
- P3: A=75pts, B=75pts (Weight 3x)
- P4: A=46pts, B=50pts (Weight 2x)
- P5: A=25pts, B=21pts (Weight 1x)
- P6: A=17pts, B=25pts (Weight 1x)
**Total: A=363pts, B=396pts**

**DECISION MARKED AS FINAL** - No further reconsideration without documented assumption trigger

**Business Impact**: 30% faster development, simpler maintenance, equally robust duplicate detection for revenue protection

‚∏ª

### **Decision: User Type Architecture (2025-08-18)**

**Decision**: 
- **Parent-child inheritance** - `user_profiles` parent table + type-specific child tables
- **Schema**: `user_profiles` + `candidate_profiles`, `employer_user_profiles`, `agency_user_profiles`, `platform_user_profiles`

**Options Considered:**

**Option A - Single Table:**
```sql
users (id, canonical_person_id, user_type, first_name, ..., skills, commission_rate, admin_rights, ...)
contact_identifiers (id, user_id FK, type, value, ...)
```
- **Rejected because**: 40-80 columns with mostly NULL values
- **Rejected because**: Complex type-specific validation logic
- **Rejected because**: Poor query performance on large table

**Option B - Separate Flat Tables:**
```sql
candidates (id, canonical_person_id, first_name, skills, ...)
employer_users (id, canonical_person_id, first_name, department, ...)
contact_identifiers (id, ???, type, value, ...)
```
- **Rejected because**: Contact identifiers cannot determine which profile they belong to
- **Rejected because**: Multi-profile support broken - no way to link contact to specific user profile
- **Integration failure**: Violates multi-profile requirement from business needs

**Option C - Parent-Child (Selected):**
```sql
canonical_persons (id, canonical_person_id FK, created_at, updated_at, status)
user_profiles (id, person_id FK, organization_id FK, profile_type, first_name, last_name, job_title, auth_user_id, ...)
contact_identifiers (id, user_profile_id FK, type, value, is_primary, is_active, ...)
candidate_profiles (user_profile_id FK, skills, education, ...)
```

**Integration Analysis:**
- **Decision 1 compatibility**: Duplicate detection via person_id ‚Üí canonical_persons ‚Üí canonical_person_id lookup
- **Decision 2 compatibility**: Contact identifiers properly link to specific user profiles  
- **Multi-profile support**: Same canonical person can have multiple user_profiles across organizations
- **Authentication integration**: auth_user_id links to Supabase authentication system

**Multi-Profile Example:**
```sql
-- Person works at two agencies
canonical_persons: {id: 1, canonical_person_id: 1}
user_profiles: {id: 10, person_id: 1, org_id: 'AgencyA', profile_type: 'agency', auth_user_id: 'supabase-uuid-1'}
user_profiles: {id: 11, person_id: 1, org_id: 'AgencyB', profile_type: 'agency', auth_user_id: 'supabase-uuid-2'}  
contact_identifiers: {user_profile_id: 10, type: 'email', value: 'john@agencyA.com'}
contact_identifiers: {user_profile_id: 11, type: 'email', value: 'john@agencyB.com'}
```

**Key SQL Queries:**
```sql
-- Within-type query (high frequency)
SELECT up.*, cp.* FROM user_profiles up 
JOIN candidate_profiles cp ON up.id = cp.user_profile_id 
WHERE up.organization_id = ? AND up.profile_type = 'candidate'

-- Cross-type contact lookup (low frequency)  
SELECT up.profile_type, up.first_name FROM contact_identifiers ci
JOIN user_profiles up ON ci.user_profile_id = up.id
WHERE ci.value = 'email@domain.com'

-- Duplicate detection (via canonical lookup)
SELECT up.* FROM user_profiles up 
JOIN canonical_persons cp ON up.person_id = cp.id
WHERE cp.canonical_person_id = ?

-- Authentication lookup
SELECT up.* FROM user_profiles up 
WHERE up.auth_user_id = 'supabase-user-uuid'
```

**Type Validation Integration:**
```sql
-- From Decision 2 - enforced in contact_identifiers table
CONSTRAINT valid_email CHECK (type != 'email' OR value ~ '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$')
```

**Key Assumptions:**
- Each user type has 10-20 unique attributes justifying separate child tables
- Within-type queries (95%+) outweigh cross-type queries (<5%)
- Multi-profile users remain <1% but architecturally critical
- JOIN performance acceptable for MVP scale (1000s records)

**Assumption Change Triggers:**
- If within-type query frequency drops below 80% ‚Üí reconsider single table
- If JOIN performance degrades >100ms ‚Üí add denormalization
- If child table attributes become similar ‚Üí consolidate tables

**DECISION MARKED AS FINAL** - No further reconsideration without documented assumption trigger

**Business Impact**: Clean multi-profile support, optimal query performance for common patterns, 30% cleaner schema vs single table approach

‚∏ª

### **Decision: Organization & Role Architecture (2025-08-19)** [PENDING APPROVAL]

## **üìö TERMINOLOGY & RESEARCH FOUNDATION**

### **Standard Multi-Tenant SaaS Terminology:**
- **TENANT** = Top-level data isolation boundary (critical security - Company A cannot see Company B data)
  - **Usage**: Primary terminology for database design and security isolation
  - **Replaces**: "Organization" to avoid confusion with departments/units
- **TENANT TYPE** = Business model classification for platform customers
  - **Values**: 'employer' (hiring companies), 'agency' (recruiting firms), 'platform' (intermediary services)
  - **Industry standard**: Based on recruiting marketplace platform terminology
- **DEPARTMENTS** = Functional units within tenant (Engineering, Sales, HR)
  - **Hierarchy**: Can have multiple parents (~1-2% frequency)
  - **Example**: Sales Operations ‚Üí reports to both Sales AND Operations heads
- **LOCATIONS** = Physical/geographic units within tenant (Country ‚Üí State ‚Üí City)
  - **Hierarchy**: Single-parent tree structure, typically 2-3 levels deep
- **HIERARCHY** = Parent-child relationships within tenant structure

### **Modern ATS Architecture Patterns** (Based on Ashby, industry research):
- **Start flat, add hierarchy later** - avoid over-engineering MVP
- **Separation of concerns** - departments (functional) vs locations (physical)
- **Flexible permission scoping** - global, department-scoped, location-scoped
- **Move operations** - departments/locations can change parent relationships

### **Industry Standard Isolation Levels:**
- **Cross-tenant isolation**: Database-level RLS (critical security requirement)
- **Intra-tenant units**: Application-level filtering (acceptable risk level)

---

## **üéØ DESIGN DECISION**

**Decision**: 
- **Three-table approach** - `tenants` + `tenant_roles` + `tenant_memberships` for centralized role/permission management
- **Flat Phase I design** - no departments/locations for MVP simplicity
- **Centralized role definitions** - eliminates permission duplication and inconsistency
- **Phase II/III extension ready** - schema supports dept/location hierarchy without major refactoring
- **Database-level RLS** for tenant isolation

**Phase I Schema (MVP)**:
```sql
-- Primary tenant table
tenants (
  id UUID PRIMARY KEY,
  tenant_type VARCHAR(20) CHECK (tenant_type IN ('employer', 'agency', 'platform')),
  name VARCHAR(200) NOT NULL,
  domains JSONB, -- ["company.com", "company.org"] - multiple domains support
  settings JSONB, -- tenant-specific configurations
  status VARCHAR(20) DEFAULT 'active',
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);

-- Centralized role definitions per tenant (eliminates permission duplication)
tenant_roles (
  id UUID PRIMARY KEY,
  tenant_id UUID REFERENCES tenants(id) ON DELETE CASCADE,
  role_name VARCHAR(100) NOT NULL, -- 'Admin', 'Senior Recruiter', 'Coordinator' (tenant-customizable)
  permissions JSONB NOT NULL, -- {"can_edit_candidates": true, "can_view_reports": false}
  is_active BOOLEAN DEFAULT true,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW(),
  
  UNIQUE(tenant_id, role_name) -- prevent duplicate role names per tenant
);

-- User assignments to centralized roles (no permission duplication)
user_role_assignments (
  id UUID PRIMARY KEY,
  user_profile_id UUID REFERENCES user_profiles(id) ON DELETE CASCADE,
  tenant_id UUID REFERENCES tenants(id) ON DELETE CASCADE,
  tenant_role_id UUID REFERENCES tenant_roles(id) ON DELETE CASCADE,
  is_active BOOLEAN DEFAULT true,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW(),
  
  UNIQUE(user_profile_id, tenant_id, tenant_role_id)
);
```

---

## **üöÄ PHASE II/III HIERARCHY EXTENSION DESIGN**

**Future-Proofing Approach**: Schema supports complex hierarchies without MVP code rewrites

### **Department Hierarchy (Multi-Parent Support)**
```sql
-- Department table with multi-parent support
departments (
  id UUID PRIMARY KEY,
  tenant_id UUID REFERENCES tenants(id) ON DELETE CASCADE,
  name VARCHAR(100) NOT NULL,
  description TEXT,
  is_active BOOLEAN DEFAULT true,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW(),
  
  UNIQUE(tenant_id, name)
);

-- Many-to-many department relationships (supports multi-parent ~1-2% cases)
department_hierarchies (
  id UUID PRIMARY KEY,
  child_department_id UUID REFERENCES departments(id) ON DELETE CASCADE,
  parent_department_id UUID REFERENCES departments(id) ON DELETE CASCADE,
  relationship_type VARCHAR(50) DEFAULT 'reports_to', -- 'reports_to', 'collaborates_with'
  is_active BOOLEAN DEFAULT true,
  created_at TIMESTAMP DEFAULT NOW(),
  
  UNIQUE(child_department_id, parent_department_id, relationship_type),
  CHECK (child_department_id != parent_department_id) -- prevent self-reference
);
```

### **Location Hierarchy (Single-Parent Tree)**
```sql
-- Location table with single-parent tree structure
locations (
  id UUID PRIMARY KEY,
  tenant_id UUID REFERENCES tenants(id) ON DELETE CASCADE,
  parent_location_id UUID REFERENCES locations(id), -- NULL for root level
  name VARCHAR(100) NOT NULL,
  location_type VARCHAR(50), -- 'country', 'state', 'city', 'office'
  address TEXT,
  workplace_type VARCHAR(50), -- 'office', 'remote', 'hybrid'
  is_active BOOLEAN DEFAULT true,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW(),
  
  UNIQUE(tenant_id, name, parent_location_id)
);
```

### **Tenant Corporate Hierarchy (Future Extension)**
```sql
-- Tenant relationships for corporate structures
tenant_relationships (
  id UUID PRIMARY KEY,
  child_tenant_id UUID REFERENCES tenants(id) ON DELETE CASCADE,
  parent_tenant_id UUID REFERENCES tenants(id) ON DELETE CASCADE,
  relationship_type VARCHAR(50), -- 'subsidiary', 'sister_company', 'joint_venture'
  ownership_percentage DECIMAL(5,2), -- for subsidiary relationships
  is_active BOOLEAN DEFAULT true,
  created_at TIMESTAMP DEFAULT NOW(),
  
  UNIQUE(child_tenant_id, parent_tenant_id, relationship_type),
  CHECK (child_tenant_id != parent_tenant_id)
);
```

### **Role Scoping Extension (NO major refactoring)**
```sql
-- Add scope columns to existing tenant_roles table
ALTER TABLE tenant_roles ADD COLUMN department_id UUID REFERENCES departments(id);
ALTER TABLE tenant_roles ADD COLUMN location_id UUID REFERENCES locations(id);
ALTER TABLE tenant_roles ADD COLUMN scope_type VARCHAR(20) DEFAULT 'tenant'; -- 'tenant', 'department', 'location'

-- Role scope examples:
-- Tenant-wide admin: {department_id: NULL, location_id: NULL, scope_type: 'tenant'}
-- Engineering recruiter: {department_id: 'eng-dept', location_id: NULL, scope_type: 'department'}  
-- SF office coordinator: {department_id: NULL, location_id: 'sf-office', scope_type: 'location'}
```

---

## **üîó INTEGRATION WITH EXISTING LOCKED TABLES**

**Primary tenant isolation via user_profiles**:
```sql
-- FK dependency resolved
user_profiles.tenant_id ‚Üí tenants.id

-- Multi-role support via centralized roles
user_role_assignments ‚Üí user_profiles (multiple roles per user per tenant)
user_role_assignments ‚Üí tenant_roles (centralized permission definitions)
```

**Tenant Isolation via RLS**:
```sql
ALTER TABLE user_profiles ENABLE ROW LEVEL SECURITY;
CREATE POLICY tenant_isolation_user_profiles ON user_profiles
  USING (tenant_id = current_setting('app.current_tenant_id')::uuid);

-- Apply RLS to all tenant tables
ALTER TABLE tenants ENABLE ROW LEVEL SECURITY;
ALTER TABLE tenant_roles ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_role_assignments ENABLE ROW LEVEL SECURITY;
```

---

## **üéØ DESIGN RATIONALE**

**1. Centralized Role Definitions**: Eliminates permission duplication and inconsistency
- **Problem solved**: Two coordinators no longer duplicate permissions in separate records
- **Consistency guaranteed**: All users with same role have identical permissions
- **Tenant customization**: Each tenant defines own role names and permissions

**2. MVP Simplicity**: Flat tenant structure for Phase I speed  
- **No departments/locations**: Simple three-table design for MVP launch
- **Extension ready**: Schema supports complex hierarchies without MVP code rewrites

**3. Future-Proof Architecture**: Supports all common enterprise scenarios
- **Multi-parent departments**: ~1-2% edge cases supported via many-to-many relationships
- **Single-parent locations**: Clean tree structure for geographic hierarchy  
- **Corporate hierarchies**: Tenant relationships for subsidiaries/sister companies

**4. Security-First Design**: Database-level tenant isolation
- **Critical isolation**: Company A cannot see Company B data under any circumstances
- **RLS enforcement**: Database guarantees isolation, prevents application bugs
- **Audit compliance**: Database-level controls for regulatory requirements

**5. Integration Compatibility**: 
- **FK dependency resolved**: `tenants.id` satisfies locked `user_profiles.organization_id FK`
- **No table rewrites**: Extension via ALTER TABLE and new tables only

**Alternatives Considered & Rejected**:

**Option A - Embed roles in user_profiles table**:
```sql
user_profiles (..., role_type VARCHAR(50), permissions JSONB)
```
- **Rejected because**: Cannot support multi-role users within same organization
- **Rejected because**: Violates single responsibility - mixing identity with role management
- **Rejected because**: No clean way to handle role transitions or temporary permissions

**Option B - Permission duplication in memberships (original flawed design)**:
```sql
tenant_memberships (..., role_type VARCHAR(50), permissions JSONB)
```
- **Rejected because**: Permission duplication creates inconsistency risk
- **Rejected because**: Two coordinators = two copies of same permissions
- **Rejected because**: Role permission changes require updating multiple records

**Option C - Single tenants table only**:
```sql
tenants (..., default_permissions JSONB)
```
- **Rejected because**: No way to support user-specific roles beyond tenant defaults
- **Rejected because**: Cannot handle admin vs specialized role distinctions
- **Rejected because**: No support for role-based queries or permission inheritance

**Option D - Application-level tenant isolation**:
```sql
-- No RLS, rely on application WHERE clauses
WHERE tenant_id = $current_tenant_id
```
- **Rejected because**: High risk of application bugs causing data leaks
- **Rejected because**: Complex application-level filtering for all tenant-sensitive queries  
- **Rejected because**: Audit/compliance requirements favor database-level controls

---

## **üìã IMPLEMENTATION EXAMPLES**

**Centralized Role Definition (Eliminates Duplication)**:
```sql
-- Define role once per tenant
tenant_roles: {id: 'coord-role-1', tenant_id: 'AgencyA', role_name: 'Coordinator', 
               permissions: {"can_edit_candidates": true, "can_view_reports": false}}

-- Multiple users assigned to same role (no duplication)
user_role_assignments: 
  {user_profile_id: 10, tenant_id: 'AgencyA', tenant_role_id: 'coord-role-1'}
  {user_profile_id: 11, tenant_id: 'AgencyA', tenant_role_id: 'coord-role-1'}
```

**Multi-Role Assignment Example**:
```sql
-- Person works as admin + account_manager at Agency A
tenant_roles: 
  {id: 'admin-role', tenant_id: 'AgencyA', role_name: 'Admin', permissions: {...}}
  {id: 'mgr-role', tenant_id: 'AgencyA', role_name: 'Account Manager', permissions: {...}}

user_role_assignments:
  {user_profile_id: 10, tenant_id: 'AgencyA', tenant_role_id: 'admin-role'}
  {user_profile_id: 10, tenant_id: 'AgencyA', tenant_role_id: 'mgr-role'}

-- Same person works at Agency B with different role
tenant_roles:
  {id: 'coord-role', tenant_id: 'AgencyB', role_name: 'Recruiting Coordinator', permissions: {...}}

user_role_assignments:
  {user_profile_id: 12, tenant_id: 'AgencyB', tenant_role_id: 'coord-role'}
```

**Key SQL Queries**:
```sql
-- Role-based access check with centralized permissions
SELECT up.*, tr.role_name, tr.permissions 
FROM user_profiles up 
JOIN user_role_assignments ura ON up.id = ura.user_profile_id
JOIN tenant_roles tr ON ura.tenant_role_id = tr.id
WHERE up.auth_user_id = ? AND up.tenant_id = ? AND ura.is_active = true

-- Get all roles for a user in a tenant
SELECT tr.role_name, tr.permissions
FROM user_role_assignments ura
JOIN tenant_roles tr ON ura.tenant_role_id = tr.id  
WHERE ura.user_profile_id = ? AND ura.tenant_id = ? AND ura.is_active = true

-- Tenant isolation (automatic via RLS)
SELECT * FROM user_profiles WHERE first_name LIKE 'John%'
-- Automatically filtered to current_setting('app.current_tenant_id')

-- Phase II department hierarchy query (multi-parent support)
WITH RECURSIVE dept_hierarchy AS (
  SELECT child_department_id as dept_id FROM department_hierarchies WHERE parent_department_id = ?
  UNION ALL
  SELECT dh.child_department_id FROM department_hierarchies dh 
  JOIN dept_hierarchy dhi ON dh.parent_department_id = dhi.dept_id
)
SELECT tr.* FROM tenant_roles tr WHERE tr.department_id IN (SELECT dept_id FROM dept_hierarchy)

-- Phase II location hierarchy query (single-parent tree)  
WITH RECURSIVE location_hierarchy AS (
  SELECT id FROM locations WHERE parent_location_id = ?
  UNION ALL
  SELECT l.id FROM locations l
  JOIN location_hierarchy lh ON l.parent_location_id = lh.id
)
SELECT tr.* FROM tenant_roles tr WHERE tr.location_id IN (SELECT id FROM location_hierarchy)
```

---

## **üìä KEY ASSUMPTIONS & CHANGE TRIGGERS**

**Key Assumptions**:
- **Tenants average 3-5 role types** each (admin + specialized roles)
- **Multi-role users <5%** of total users but architecturally important
- **Role permission queries moderate frequency** (user login, permission checks)
- **Role permissions rarely change** once defined (simplifies caching)
- **Department multi-parent cases ~1-2%** (most departments single parent)
- **Location hierarchy typically 2-3 levels** (Country ‚Üí State ‚Üí City)
- **RLS performance acceptable** for MVP scale (thousands of records per tenant)

**Assumption Change Triggers**:
- If **role permission queries exceed 50%** of total queries ‚Üí consider role caching
- If **tenants average >10 role types** ‚Üí consider role hierarchy tables
- If **RLS performance degrades >100ms** ‚Üí evaluate application-level filtering
- If **department multi-parent >10%** ‚Üí consider optimization for matrix queries
- If **location hierarchy >5 levels** ‚Üí add materialized path columns for performance

**DECISION STATUS: PENDING APPROVAL** - Awaiting business validation and approval

**Business Impact**: 
- **Eliminates permission duplication** - consistent role definitions across all users
- **Enables MVP launch** with flat tenant structure and simple three-table design
- **Future-proof architecture** - supports complex hierarchies without MVP code rewrites  
- **Critical tenant isolation** via database-level RLS for regulatory compliance
- **Resolves FK dependency** - `tenants.id` satisfies locked `user_profiles.tenant_id FK`

---

## **üìö LESSONS LEARNED FOR FUTURE TABLE DESIGN**

### **üö® CRITICAL MISTAKES TO AVOID:**

**1. Permission Duplication Anti-Pattern**
- ‚ùå **Problem**: Storing permissions in assignment tables creates inconsistency risk
- ‚úÖ **Solution**: Centralize role definitions, reference via FK
- **Example**: Two coordinators sharing one role definition vs duplicating permissions

**2. Vague Table Naming**  
- ‚ùå **Problem**: "tenant_memberships" - unclear what it contains
- ‚úÖ **Solution**: Descriptive names like "user_role_assignments" - purpose is obvious
- **Rule**: Table name should clearly indicate its function

**3. Startup Domain Assumptions**
- ‚ùå **Problem**: Single domain field assumes companies don't change
- ‚úÖ **Solution**: JSONB array for multiple domains, handles startup evolution
- **Lesson**: Don't assume business stability in early-stage companies

**4. Terminology Inconsistency**
- ‚ùå **Problem**: Mixing "organization" and "tenant" creates confusion  
- ‚úÖ **Solution**: Use industry-standard "tenant" consistently across all tables
- **Rule**: Lock terminology early, update ALL references simultaneously

**5. Premature FK "Locking"**
- ‚ùå **Problem**: Declaring tables "locked" before resolving FK dependencies
- ‚úÖ **Solution**: Verify ALL FK relationships work before marking tables final
- **Process**: FK validation must be part of table design completion

### **‚úÖ SUCCESSFUL PATTERNS TO REUSE:**

**1. Centralized Definition Pattern**
- Store shared configurations once, reference via FK
- Prevents duplication, ensures consistency
- **Apply to**: Job templates, submission stages, workflow definitions

**2. Parent-Child Inheritance**
- Common fields in parent table, type-specific in child tables
- Clean separation, optimal query performance
- **Apply to**: Job types (base job + employer/agency/platform specific data)

**3. Future-Proof Extension Strategy**
- Design Phase I simple, extend via ALTER TABLE + new tables
- No MVP code rewrites needed
- **Apply to**: Job hierarchy, submission workflows, candidate matching

**4. Database-Level Security**
- Use RLS for critical isolation boundaries
- Application logic for business rules
- **Apply to**: Job visibility, submission access, candidate data protection

**5. Industry Standard Terminology**
- Research standard terms before inventing new ones
- Align with existing ATS/SaaS conventions
- **Apply to**: Job status, submission stages, candidate sources

### **üéØ PRE-DESIGN CHECKLIST FOR JOB TABLES:**

- [ ] **Business requirements locked** - no assumptions, confirm with stakeholder
- [ ] **Terminology researched** - use industry standard terms  
- [ ] **FK dependencies mapped** - identify all table relationships upfront
- [ ] **Centralization opportunities** - avoid duplication patterns
- [ ] **Extension strategy** - design Phase I simple, Phase II complex
- [ ] **Security boundaries** - identify tenant vs intra-tenant isolation needs

### **Decision: Experience Levels Architecture (2025-08-21)**

**Decision**: 
- **Application Constants** for Phase I with 8 platform-normalized levels
- **Platform normalization** for cross-tenant sourcing compatibility
- **Phase II tenant customization** via lookup table mapping to platform levels

**Platform Default Experience Levels**:
```typescript
const PLATFORM_EXPERIENCE_LEVELS = {
  'intern': { name: 'Intern', sort_order: 1, years_min: 0, years_max: 1 },
  'junior': { name: 'Junior', sort_order: 2, years_min: 0, years_max: 2 },
  'mid': { name: 'Mid', sort_order: 3, years_min: 3, years_max: 6 },
  'senior': { name: 'Senior', sort_order: 4, years_min: 7, years_max: 12 },
  'staff': { name: 'Staff', sort_order: 5, years_min: 8, years_max: 15 },
  'manager': { name: 'Manager', sort_order: 6, years_min: 5, years_max: 20 },
  'director': { name: 'Director', sort_order: 7, years_min: 10, years_max: 25 },
  'exec': { name: 'Executive', sort_order: 8, years_min: 15, years_max: 50 }
} as const;
```

**Schema Implementation**:
```sql
-- candidate_profiles table
experience_level VARCHAR(20) CHECK (experience_level IN (
  'intern', 'junior', 'mid', 'senior', 'staff', 'manager', 'director', 'exec'
)) DEFAULT NULL,
years_experience DECIMAL(4,1),
experience_last_updated DATE DEFAULT CURRENT_DATE,
experience_notes TEXT
```

**Research Foundation**:
- **LinkedIn standard**: 7 categories (Internship, Entry Level, Associate, Mid-Senior Level, Director, Executive, Not Applicable)
- **Other ATS**: Custom fields, no standardized categories (Greenhouse, Ashby, Bullhorn)
- **Auto-aging**: No ATS platforms automatically update experience - all require manual updates
- **Sourcing requirements**: Platform normalization needed for cross-tenant candidate matching

**Design Rationale**:
1. **Platform Normalization**: "Senior" means same thing across all tenants for sourcing
2. **Tenant Flexibility**: Phase II allows custom labels that map to platform levels
3. **Tech Industry Focus**: Added "Staff" level for senior individual contributors
4. **Management Track**: Separate "Manager" from IC progression
5. **Fractional Support**: DECIMAL(4,1) supports bootcamp graduates (1.5 years)

**Phase II Extension Design**:
```sql
-- Future tenant customization (Phase II)
CREATE TABLE tenant_experience_levels (
  tenant_id UUID REFERENCES tenants(id),
  platform_key VARCHAR(20), -- Maps to PLATFORM_EXPERIENCE_LEVELS
  custom_label VARCHAR(100), -- "L5 Engineer", "Senior SWE"
  is_active BOOLEAN DEFAULT true
);
```

**Alternatives Considered & Rejected**:
- **LinkedIn 7-level copy**: Missing tech industry granularity (no "Staff" level)
- **Lookup tables from start**: Over-engineered for MVP, 90% tenants use defaults
- **Years-based auto-calculation**: Too subjective, no ATS platforms do this

**Key Assumptions**:
- 90% of tenants will use platform defaults without customization
- Experience level is manual selection, not calculated from years
- Platform normalization more important than tenant branding for MVP
- Tech companies need "Staff" level distinction for senior ICs

**DECISION MARKED AS FINAL** - 8-level platform standard with Phase II customization path

**STATUS**: Architecture complete - 12 tables locked, experience levels decided, ready for job table design

‚∏ª

